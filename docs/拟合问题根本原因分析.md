# 拟合问题的根本原因分析

## 🔍 调用链追踪

### 当前项目的拟合流程：

```
1. Controller.on_fit_data
   ↓
2. fit_data(method='LocalBivariate', x_data, y_data, dataframe=data.dataframe, data_obj=data)
   ↓
3. FittingWrapper._fit_local_bivariate
   ↓
4. 检查DataFrame格式 → 转换为宽表（Time, 0.0）
   ↓
5. 保存临时Excel
   ↓
6. 调用model_runner(tmp_excel_path)
   ↓
7. LocalBivariate算法计算
   ↓
8. 返回 (T_data, Y_data, Y_pred)
```

## ❌ 问题1：浓度为0导致Y_pred全是0

**实际测试结果**：
```
[7] Y_pred（前5个）:
[[0.]
 [0.]
 [0.]
 [0.]
 [0.]]

Rmax: 74.4947
kon: 1.0000e+06
koff: 1.0000e-02
KD: 1.0000e-08
```

**原因**：LocalBivariate的模型公式（第56行）：
```python
Eq = Bmax_value * radioligands / (radioligands + Kd)
```

当`radioligands=0`（我们用的列名`'0.0'`）时：
```
Eq = Bmax_value * 0 / (0 + Kd) = 0
→ Y预测 = 0 + 0 * (...) = 0
```

**这就是为什么拟合结果是直线（实际是零线）！**

---

## ❌ 问题2：数据加载方式错误

**JSON文件信息**：
```
文件名: 多循环igg_20240918163627L.json
CalculateFormula: 101          ← SingleCycle算法标识
样本数量: 8                     ← 多循环，8个样本！
第一个样本浓度: 0.0            ← 可能是参考样本
```

**当前加载逻辑** (`data_model.py` 第143-145行)：
```python
base_data = first_item.get('BaseData', [])  # 只加载第一个样本！
if base_data:
    self.dataframe = pd.DataFrame(base_data)
```

**问题**：
1. **只加载了第一个样本**（浓度=0的参考样本）
2. **忽略了其他7个样本**
3. **LocalBivariate需要多浓度数据**（Time + 浓度1 + 浓度2 + ...）

---

## ❌ 问题3：算法选择错误

**LocalBivariate算法的设计目的**：
- 用于**多浓度**数据（如0 nM, 10 nM, 20 nM, ...）
- 通过**同时拟合多条曲线**来确定动力学参数
- 输入格式：宽表（Time | 0.0 | 10.0 | 20.0 | ...）

**SingleCycle算法的设计目的** (根据文件名和代码)：
- 用于**多循环**数据（多次重复的结合-解离循环）
- 输入格式：可能是每个循环作为独立的段

**当前JSON数据**：
- 文件名：`多循环igg`
- `CalculateFormula: 101` ← 应该用SingleCycle
- 但我们用了LocalBivariate！

---

## 🔑 旧项目是如何工作的？

### 推测1：算法路由逻辑

旧项目可能有类似这样的逻辑：
```python
if data.attributes['fittingformula'] == 101:
    # 使用SingleCycle算法
    result = SingleCycleFitting(...)
elif data.attributes['fittingformula'] == 102:
    # 使用LocalBivariate算法
    result = LocalBivariateFitting(...)
```

### 推测2：多样本数据构建

旧项目可能会：
```python
# 对于多循环数据
samples = data['CalculateDataList']
# 提取每个样本的浓度和BaseData
concentrations = [s['Concentration'] for s in samples]
base_data_list = [s['BaseData'] for s in samples]

# 构建宽表
wide_df = build_wide_table(concentrations, base_data_list)
```

而不是只用第一个样本！

---

## ✅ 正确的解决方案

### 方案1：根据CalculateFormula选择算法 ✅ 推荐

```python
def on_fit_data(self, data_id, method):
    data = self.data_manager.get_data(data_id)
    
    # ⭐ 根据JSON中的fittingformula自动选择算法
    formula = data.attributes.get('fittingformula')
    if formula == 101:
        method = 'SingleCycle'
    elif formula == 102:
        method = 'LocalBivariate'
    elif formula == 103:
        method = 'GlobalBivariate'
    
    fit_result = fit_data(method, x_data, y_data, ...)
```

### 方案2：正确加载多循环数据

修改`data_model.py`的`_load_from_file`：

```python
def _load_from_file(self, data: Dict):
    # ...
    
    if 'CalculateDataList' in data and len(data['CalculateDataList']) > 0:
        formula = data.get('CalculateFormula')
        
        if formula == 101:  # SingleCycle - 多循环数据
            # 加载所有样本并构建宽表
            self.dataframe = self._build_multicycle_dataframe(data['CalculateDataList'])
        elif formula in [102, 103]:  # Bivariate - 多浓度数据
            # 加载所有浓度并构建宽表
            self.dataframe = self._build_multiconcentration_dataframe(data['CalculateDataList'])
        else:
            # 回退：只加载第一个样本
            base_data = data['CalculateDataList'][0].get('BaseData', [])
            self.dataframe = pd.DataFrame(base_data)
```

### 方案3：修复单样本转宽表的浓度值

如果必须支持单样本 + LocalBivariate，至少要用非零浓度：

```python
# ⭐ 从Data的attributes获取实际浓度
concentration = data_obj.attributes.get('calculatedatalist_concentration', 1.0)
if concentration is None or concentration <= 0:
    concentration = 1.0  # 默认非零值
    
wide_df = pd.DataFrame({
    'Time': df[time_col],
    str(concentration): df[value_col]  # ← 使用实际浓度，不是'0.0'
})
```

---

## 📊 问题总结

| 问题 | 当前状态 | 应该是 |
|------|---------|--------|
| 数据加载 | 只加载第一个样本 | 根据算法类型加载所有样本 |
| 算法选择 | 手动选LocalBivariate | 根据CalculateFormula自动选 |
| 浓度值 | 使用'0.0'占位 | 使用实际浓度或非零默认值 |
| 数据格式 | 单列（Time, YValue） | 宽表（Time, 浓度1, 浓度2, ...） |

---

## 🎯 下一步行动

1. **立即检查**：JSON中其他7个样本的浓度和数据
2. **修改加载逻辑**：支持多样本数据的正确构建
3. **实现算法路由**：根据CalculateFormula自动选择算法
4. **测试SingleCycle**：验证SingleCycle算法是否可用

---

## 📝 参考

- `model_data_process/LocalBivariate.py` - LocalBivariate算法实现
- `XlementFitting/SingleCycle.py` - SingleCycle算法实现
- `XlementFitting/FileProcess/Json2excelSingleCycle.py` - 单循环数据转换
- `src/models/data_model.py` 第143行 - 当前加载逻辑
- `src/utils/fitting_wrapper.py` 第148行 - 单样本转宽表逻辑

