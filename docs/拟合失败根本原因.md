# 拟合失败的根本原因

## 🔍 问题发现

通过直接测试`model_runner`，发现拟合算法**成功执行**，但结果完全不对：

### 实际输出
```
Rmax: 319.8252
kon: 3.2930e+03
koff: 1.3539e-158  ← 接近0！
KD: 4.1113e-162    ← 接近0！

Y_data（原始）: -0.43, -1.1, -0.8, ... （负值）
Y_pred（拟合）: 0.00107, 0.00219, 0.00438, ... （很小的正值）

Y_pred最大值: 0.98
Y_pred标准差: 0.20
```

### 数据特征
```
时间点：0, 1, 2, 3, ..., 14  （共15个点）
浓度：8个（0.0, 1.02e-9, 2.08e-9, ..., 6.67e-8）
```

---

## ❌ 根本原因

### 1. time_break硬编码为133
`model_data_process/LocalBivariate.py` 第117行：
```python
time_break = 133  # 硬编码！
```

但您的数据：
- **时间范围**：0 ~ 14（只有15个点）
- **time_break = 133远超数据范围！**

### 2. 导致的后果
SPR拟合模型中：
```python
# 第59-60行
T_flag_diss = (T_array > Time0)  # 解离阶段标记
T_flag_ass = (T_array <= Time0)  # 结合阶段标记
```

当`Time0=133`，而所有数据点`T < 15`时：
- `T_flag_diss`全是0（没有解离阶段）
- `T_flag_ass`全是1（全部是结合阶段）

这导致模型退化，无法正确拟合结合-解离曲线。

---

## ✅ 解决方案

### 方案1：从数据估计time_break（自动）

修改`model_data_process/LocalBivariate.py`第117行：
```python
# 旧代码
time_break = 133

# 新代码：自动估计
# 找到Y值最大值的位置作为结合-解离分界点
Y_max_idx = np.unravel_index(np.argmax(Y_data), Y_data.shape)[0]
time_break = T_data[Y_max_idx, 0]
print(f"自动估计time_break: {time_break}")
```

### 方案2：从JSON读取（如果有）

如果JSON中有`CombineEndIndex`或`DissociationEndIndex`：
```python
# 从JSON attributes读取
combine_end = data.attributes.get('calculatedatalist_combineendindex')
if combine_end is not None and combine_end > 0 and combine_end < len(T_data):
    time_break = float(combine_end)
else:
    # 回退到估计
    time_break = estimate_from_data()
```

### 方案3：让用户指定

在拟合对话框中添加参数：
```python
# fitting_method_dialog.py
'LocalBivariate': {
    'parameters': {
        'time_break': ('结合-解离分界点', -1, int, (-1, 10000)),  # -1表示自动估计
        ...
    }
}
```

---

## 🔧 立即修复

我建议直接修改`LocalBivariate.py`，使用自动估计：

```python
# 第115-120行改为：
# 自动估计time_break
Y_max_idx = np.unravel_index(np.argmax(Y_data), Y_data.shape)[0]
time_break = float(T_data[Y_max_idx, 0])

# 如果估计的time_break太小或太大，使用数据范围的1/2
if time_break < 1 or time_break >= len(T_data):
    time_break = len(T_data) // 2

print(f"自动估计time_break: {time_break} (Y最大值位置: {Y_max_idx})")
```

---

## 📊 预期效果

修复后：
- time_break会正确设置为数据范围内的值（如7-10）
- 模型能正确区分结合和解离阶段
- koff和KD会收敛到合理值（而不是e-158）
- Y_pred的scale会匹配Y_data

---

## 🎯 为什么旧项目能工作？

可能的原因：
1. 旧项目使用的测试数据恰好有133个时间点或更多
2. 旧项目可能有额外的预处理步骤我们没有看到
3. 旧项目可能已经手动修改过time_break值

---

## 🚀 下一步

立即修复`model_data_process/LocalBivariate.py`的time_break硬编码问题。

