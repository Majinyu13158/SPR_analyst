# 多数据拟合实现总结

## ✅ 已完成的功能

### 1. 多选数据源对话框
**文件**: `src/views/dialogs/fitting_method_dialog.py`

**改动**:
- 将单选下拉框(`QComboBox`)改为多选列表(`QListWidget` + `MultiSelection`)
- 添加复选框支持，用户可勾选多个数据
- 返回值从单个`data_id`改为列表`data_ids`
- 对话框标题提示："可多选，LocalBivariate将合并所选数据列"

**效果**:
```
数据源选择：
☑ [1] 多循环igg (8浓度)  (15, 9)
☑ [2] 对照组数据  (15, 5)
☐ [3] 重复实验  (15, 7)
```

---

### 2. 去掉预先选中数据的限制
**文件**: `src/controllers/main_controller_full.py`

**改动**:
- 删除了`_on_fit_from_menu()`中的检查：
  ```python
  # 旧代码：
  if self.current_data_id is None:
      self.view.show_error("操作失败", "请先在左侧选择一个数据节点")
      return
  
  # 新代码：直接弹出对话框，无需预先选中
  ```

**效果**: 
- 用户可以直接点击菜单/工具栏的"拟合"按钮
- 对话框弹出后选择数据源
- 支持"从无选中状态"开始拟合流程

---

### 3. 多数据合并拟合
**文件**: `src/controllers/main_controller_full.py`

**新方法**: `on_fitting_requested_multi(data_ids, method)`

**逻辑**:
```python
# 步骤1：收集所有DataFrame
for data_id in data_ids:
    data = self.data_manager.get_data(data_id)
    all_dataframes.append(data.dataframe.copy())

# 步骤2：合并为宽表
# 假设每个DataFrame格式：Time | 浓度1 | 浓度2 | ...
merged_df = 第一个DataFrame.copy()
for 其他DataFrame in all_dataframes[1:]:
    # 只取浓度列（跳过Time列）
    merged_df[浓度列] = 其他DataFrame[浓度列]

# 步骤3：创建临时合并Data对象
combined_data_id = self.data_manager.add_data(
    name="合并数据(N组): ...",
    dataframe=merged_df
)

# 步骤4：一次性调用LocalBivariate
self.on_fitting_requested(combined_data_id, method)
```

**关键**:
- **不是**逐个调用拟合（不是`for data_id: fit(data_id)`）
- **而是**先合并后拟合（`merge_all() → fit_once()`）
- 符合LocalBivariate设计：同时处理多浓度数据

**示例**:
```
选中3个数据：
- Data1: Time | 0.0 | 1.0e-9
- Data2: Time | 2.0e-9 | 4.0e-9
- Data3: Time | 8.0e-9

合并后：
Time | 0.0 | 1.0e-9 | 2.0e-9 | 4.0e-9 | 8.0e-9

一次性调用LocalBivariate → 同时拟合5条曲线
```

---

### 4. 修复结果表格格式化错误
**文件**: `src/views/widgets/data_tables.py`

**问题**: 
```python
# 旧代码：所有值都用科学计数法
self.setItem(row_idx, 1, self._create_item(f"{value_tuple[0]:.6e}"))
# 当value是字符串时报错：Unknown format code 'e' for object of type 'str'
```

**修复**:
```python
# 新代码：判断类型
if isinstance(val, str):
    self.setItem(row_idx, 1, self._create_item(val))  # 字符串直接显示
elif isinstance(val, (int, float)) and not isinstance(val, bool):
    self.setItem(row_idx, 1, self._create_item(f"{val:.6e}"))  # 数值用科学计数法
else:
    self.setItem(row_idx, 1, self._create_item(str(val)))  # 其他类型转字符串
```

**效果**:
```
参数名         值                  误差        单位
DataSource     合并数据(3组)...   -           -
Method         LocalBivariate     -           -
Rmax           4.523400e+01       -           RU
Kon            1.234500e+05       -           1/(M*s)
Koff           2.345600e-03       -           1/s
KD             1.901200e-08       -           M
```

---

### 5. 结果显示增强
**文件**: `src/controllers/main_controller_full.py`

**改动**:
```python
# 在拟合结果中添加元信息
params_with_meta = {
    'DataSource': (data_source_name, None, ''),  # 数据来源
    'Method': (method, None, ''),                # 拟合方法
    **params_with_meta                           # 原有参数（Rmax, Kon, Koff, KD）
}
result.set_parameters(params_with_meta)
```

**效果**:
- 用户可以清楚看到每次拟合使用的数据源
- 可以区分不同方法的结果
- 便于追溯和对比

---

## 📊 完整工作流程

### 单数据拟合
```
1. 用户点击"拟合"（无需预先选中）
   ↓
2. 弹出对话框，勾选1个数据
   ↓
3. 选择方法（如LocalBivariate）
   ↓
4. 调用 on_fitting_requested(data_id, method)
   ↓
5. 显示结果（包含DataSource和Method）
```

### 多数据合并拟合
```
1. 用户点击"拟合"（无需预先选中）
   ↓
2. 弹出对话框，勾选多个数据（如3个）
   ↓
3. 选择方法（如LocalBivariate）
   ↓
4. 调用 on_fitting_requested_multi([data_ids], method)
   ├─ 收集3个DataFrame
   ├─ 合并为宽表（Time + 所有浓度列）
   ├─ 创建临时合并Data对象
   └─ 调用 on_fitting_requested(combined_id, method)
   ↓
5. LocalBivariate一次性处理所有浓度
   ↓
6. 显示结果（DataSource显示"合并数据(3组): ..."）
```

---

## 🎯 关键设计理念

### LocalBivariate的正确用法
**错误做法** ❌:
```python
# 对每个数据单独调用
for data_id in data_ids:
    fit_data(data_id)  # 3次独立拟合，结果不一致
```

**正确做法** ✅:
```python
# 先合并，再拟合
merged_data = merge_all(data_ids)  # 合并为宽表
fit_data(merged_data)              # 1次拟合，同时处理所有浓度
```

### 为什么这样设计？
1. **科学原理**: SPR实验中，不同浓度的曲线需要**同时拟合**才能准确计算动力学参数（Kon, Koff, KD）
2. **算法设计**: LocalBivariate内部使用全局优化，需要看到所有浓度的数据才能找到最优解
3. **结果一致性**: 合并拟合保证所有曲线使用相同的Kon/Koff参数

---

## 🔧 技术细节

### 数据格式要求
所有参与合并的DataFrame必须：
1. 第一列是`Time`（或`time`, `XValue`, `X`）
2. 后续列是浓度值（列名必须是数值，如`0.0`, `1.0e-9`）
3. 时间点数量一致

### 合并策略
```python
# DataFrame1: Time | 0.0 | 1.0e-9
# DataFrame2: Time | 2.0e-9 | 4.0e-9

# 合并后:
merged = DataFrame1.copy()              # 保留Time和所有浓度列
merged['2.0e-9'] = DataFrame2['2.0e-9'] # 添加DataFrame2的浓度列
merged['4.0e-9'] = DataFrame2['4.0e-9']

# 结果: Time | 0.0 | 1.0e-9 | 2.0e-9 | 4.0e-9
```

### 列名冲突处理
```python
if col in merged_df.columns:
    # 列名已存在，添加后缀避免覆盖
    new_col_name = f"{col}_{idx}"
    merged_df[new_col_name] = df[col].values
```

---

## 📝 测试建议

### 测试场景1：单数据拟合
1. 不选中任何树节点
2. 点击菜单"拟合"
3. 勾选1个数据
4. 确认拟合成功，结果显示正确的DataSource

### 测试场景2：多数据合并拟合
1. 加载多个JSON（每个8浓度）
2. 点击菜单"拟合"
3. 勾选3个数据
4. 确认：
   - 合并后的DataFrame列数 = 1(Time) + 8×3(浓度) = 25
   - LocalBivariate一次性处理24条曲线
   - 结果显示"合并数据(3组): ..."

### 测试场景3：格式化显示
1. 完成拟合
2. 切换到"拟合结果"Tab
3. 确认：
   - `DataSource`和`Method`显示为字符串（无`.e+00`）
   - `Rmax`, `Kon`, `Koff`, `KD`显示为科学计数法
   - 无格式化错误

---

## 🎉 总结

**已实现**:
- ✅ 多选数据源（复选框）
- ✅ 去掉预先选中限制
- ✅ 多数据合并拟合（一次性调用LocalBivariate）
- ✅ 结果格式化修复（字符串vs数值）
- ✅ 结果显示数据源和方法

**符合需求**:
- ✅ LocalBivariate支持同时处理多组数据
- ✅ 不是每组单独调用，而是合并后统一调用
- ✅ 拟合结果包含完整参数（DataSource, Method, Rmax, Kon, Koff, KD）

**后续优化**（可选）:
- 从LocalBivariate底层提取真实的Kon/Koff/KD值（目前是占位/估计）
- 支持手动调整合并策略（例如指定哪些列参与合并）
- 添加合并预览（显示合并后的宽表结构）

